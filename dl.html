<!-- Before you ask.. Yes, I did in fact use ChatGPT for this script
	 List of parameters:
        // 1. os - Operating system (e.g., windows, mac, linux, android, ios)
        // 2. repo - Repository name to download from
        // 3. source-code - Type of download (1 for zip with source code, 2 for main branch source)
        // 4. ver - Specific version tag to fetch
        // 5. dev - Indicates if the development version should be fetched (1 for true)
        // 6. file - Specific file name to fetch
        // 7. owner - GitHub owner name (default: pikakid98-games) -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Downloading...</title>
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
            text-align: center;
        }

        #invalid-os-warning {
            color: red;
            font-size: 24px;
        }

        a {
            color: #bb86fc;
        }

        #header-image {
            max-width: 100%;
            height: auto;
        }

        #noscript-warning {
            color: red;
            font-size: 20px;
            margin: 20px;
        }
    </style>
</head>

<body>
    <noscript>
        <div id="noscript-warning">Warning! NoScript detected! This website will not work without Javascript. Sorry about that.</div>
    </noscript>
    <div id="download-container">
        <div>
            <img id="header-image" src="assets/pghead.png" alt="Header Image" style="max-width: 100%; height: auto;">
        </div>
        <h1 id="download-title" style="display: none;">Downloading the files now</h1>
        <p id="download-prompt" style="display: none;">If the download has not started, <a id="download-link" href="#">Click Here</a></p>
        <div id="message"></div>
        <div id="invalid-os-warning"></div>
    </div>
    <script>
        function getQueryParameters() {
            const params = {};
            const queryString = window.location.search.substring(1);
            const regex = /([^&=]+)=([^&]*)/g;
            let m;
            while (m = regex.exec(queryString)) {
                params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
            }
            return params;
        }

        function getOperatingSystem() {
            const params = getQueryParameters();
            if (params['os']) {
                const os = params['os'].toLowerCase();
                if (os === 'android' || os === 'ios') {
                    return 'invalid'; // This case will redirect to the Rickroll
                }
                if (['windows', 'mac', 'linux'].includes(os)) {
                    return os;
                } else {
                    return 'invalid';
                }
            }

            const userAgent = window.navigator.userAgent;
            if (userAgent.indexOf("Windows") !== -1) {
                return "windows";
            } else if (userAgent.indexOf("Mac") !== -1) {
                return "mac";
            } else if (userAgent.indexOf("Linux") !== -1) {
                return "linux";
            }
            return "unknown";
        }

        async function fetchReleases(repoName, owner) {
            const response = await fetch(`https://api.github.com/repos/${owner}/${repoName}/releases`);
            if (response.status === 403) {
                const remaining = response.headers.get('X-RateLimit-Remaining');
                const reset = response.headers.get('X-RateLimit-Reset');
                if (remaining === '0') {
                    const resetTime = new Date(reset * 1000);
                    throw new Error(`Rate limit exceeded. Please try again after ${resetTime.toLocaleString()}.`);
                }
            }
            if (!response.ok) {
                throw new Error('Failed to fetch releases');
            }
            return await response.json();
        }

        async function fetchSpecificRelease(repoName, version, owner) {
            const response = await fetch(`https://api.github.com/repos/${owner}/${repoName}/releases/tags/${version}`);
            if (!response.ok) {
                throw new Error('Failed to fetch specific version release');
            }
            return await response.json();
        }

        async function fetchLatestPreRelease(repoName, owner) {
            const response = await fetch(`https://api.github.com/repos/${owner}/${repoName}/releases?per_page=1`);
            if (!response.ok) {
                throw new Error('Failed to fetch pre-releases');
            }
            const releases = await response.json();
            return releases;
        }

        async function downloadFile() {
            const params = getQueryParameters();

            // Check if there are no parameters
            if (Object.keys(params).length === 0) {
                alert("No query parameters present. Closing the tab.");
                window.close(); // Close the tab if no parameters are present
                return; // Stop further execution
            }

            const ownerParam = params['owner'] || 'pikakid98-games'; // Default to 'pikakid98-games' if not specified
            const repoParam = params['repo'];
            const specificFileParam = params['file'];
            const sourceCodeParam = params['source-code'];
            const versionParam = params['ver']; // Get the 'ver' parameter
            const isDev = params['dev'] === "1"; // Check for dev parameter

            if (!repoParam) {
                displayMessage("No repository specified in the query parameter.");
                return;
            }

            const repoName = repoParam;
            let fileUrl;
            const os = getOperatingSystem();

            if (os === 'invalid') {
                // Redirect to Rickroll if iOS or Android is chosen.
                window.location.href = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"; // Redirect link to Rickroll
                return; // Stop further execution
            }

            try {
                let releases;

                if (versionParam) {
                    // Fetch specific version if 'ver' parameter is provided
                    const release = await fetchSpecificRelease(repoName, versionParam, ownerParam);
                    releases = [release];
                } else {
                    // Fetch latest releases
                    releases = await fetchReleases(repoName, ownerParam);
                }

                // Determine file URL based on source code parameter or specific file request
                if (sourceCodeParam === '1') {
                    fileUrl = releases[0].zipball_url;
                } else if (sourceCodeParam === '2') {
                    fileUrl = `https://github.com/${ownerParam}/${repoName}/archive/refs/heads/main.zip`;
                } else {
                    const assets = releases.flatMap(release => release.assets);
                    if (specificFileParam) {
                        const specificFile = assets.find(asset => asset.name === specificFileParam);
                        if (specificFile) {
                            fileUrl = specificFile.browser_download_url;
                        } else {
                            throw new Error(`File "${specificFileParam}" not found in the repository.`);
                        }
                    } else {
                        // Default to finding a suitable file based on OS
                        const sevenZipFiles = assets.filter(asset => asset.name.endsWith('.7z'));

                        if (os === "windows") {
                            if (sevenZipFiles.length > 0) {
                                fileUrl = sevenZipFiles[0].browser_download_url;
                            }
                        } else if (os !== "unknown") {
                            const osSpecificFiles = sevenZipFiles.filter(asset => asset.name.endsWith(`_${os}.7z`));
                            if (osSpecificFiles.length > 0) {
                                fileUrl = osSpecificFiles[0].browser_download_url;
                            }
                        }

                        if (!fileUrl) {
                            throw new Error(`No appropriate file found for OS: ${os} in this repository.`);
                        }
                    }
                }

                // Check for dev parameter
                if (isDev && !versionParam) { // Ensure we only check for dev if no version parameter is set
                    const latestPreRelease = await fetchLatestPreRelease(repoName, ownerParam);
                    const stableReleaseDate = new Date(releases[0].published_at);
                    const latestPreReleaseFound = latestPreRelease.find(release => release.prerelease);
                    if (latestPreReleaseFound) {
                        const latestPreReleaseDate = new Date(latestPreReleaseFound.published_at);
                        if (latestPreReleaseDate < stableReleaseDate) {
                            throw new Error("The latest version is stable. Cannot download pre-release.");
                        }
                        fileUrl = latestPreReleaseFound.assets[0].browser_download_url; // Assuming you want the first asset
                    } else {
                        throw new Error("No pre-release version available.");
                    }
                }

                document.getElementById("download-title").style.display = "block";
                document.getElementById("download-prompt").style.display = "block";
                document.getElementById("download-link").href = fileUrl;
                window.location = fileUrl;
                console.log("Download initiated for: " + fileUrl);

                setTimeout(() => {
                    window.history.back();
                }, 3000);

            } catch (error) {
                console.error(error);
                displayMessage("Error fetching releases: " + error.message);
            }
        }

        function displayMessage(msg) {
            const messageDiv = document.getElementById("message");
            messageDiv.innerHTML = '';
            messageDiv.textContent = msg;
        }

        window.onload = downloadFile;
    </script>

</body>

</html>
